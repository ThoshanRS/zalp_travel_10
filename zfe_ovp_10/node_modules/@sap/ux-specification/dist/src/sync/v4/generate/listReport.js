"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateListReportSchemaV4 = exports.addSelectionFields = void 0;
const utils_1 = require("../utils/utils");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../extensionLogger");
const common_1 = require("../../common");
const ROOT_PROPERTIES_ORDER = ['filterBar', 'chart', 'table'];
/**
 * Adds the selection fields to the app schema, as properties of the FilterBar
 * @param {EntityType} entityType - the entity type as part of the AVT ConvertedMetadata
 * @param {Definition} appSchema - the app specific schema that shall get enhanced
 * @param {AnnotationTerm<SelectionFields>} selectionFieldsAnnotation - the UI.SelectionField annotation
 * @param {Definition} [selectionFieldsDefinition] - Schema definitions of selection fields
 */
function addSelectionFields(entityType, appSchema, selectionFieldsAnnotation, selectionFieldsDefinition) {
    if (!selectionFieldsDefinition) {
        selectionFieldsDefinition = appSchema.definitions.SelectionFields;
        selectionFieldsDefinition.additionalProperties = false;
        selectionFieldsDefinition.properties = {};
    }
    if (entityType) {
        selectionFieldsDefinition[ux_specification_types_1.SchemaTag.annotationPath] = (0, common_1.createAnnotationPath)(entityType.fullyQualifiedName, "com.sap.vocabularies.UI.v1.SelectionFields" /* UIAnnotationTerms.SelectionFields */);
    }
    if (selectionFieldsAnnotation) {
        let i = 0;
        selectionFieldsAnnotation?.forEach((selectionField) => {
            let description = selectionField.value;
            const fieldDefinition = 'SelectionField::' + (0, common_1.prepareRef)(selectionField.value);
            if (selectionField.type === 'PropertyPath') {
                description = (0, common_1.getLabelForPropertyPath)(selectionField, entityType);
            }
            selectionFieldsDefinition.properties[fieldDefinition] = {
                $ref: common_1.DEFINITION_LINK_PREFIX + fieldDefinition
            };
            selectionFieldsDefinition.properties[fieldDefinition][ux_specification_types_1.SchemaTag.propertyIndex] = i;
            const dataType = (0, common_1.determineDataType)(selectionField);
            appSchema.definitions[fieldDefinition] = {
                type: 'object',
                properties: {},
                description,
                additionalProperties: false,
                ...(dataType && { dataType })
            };
            appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.isViewNode] = true;
            appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.keys] = [
                { name: ux_specification_types_1.SchemaKeyName.value, value: `${selectionField.value}` }
            ];
            if (selectionField.$target?.fullyQualifiedName.indexOf('@') > -1) {
                appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.target] = selectionField.$target.fullyQualifiedName
                    .split('@')[0]
                    .split('/')[0];
            }
            else if (selectionField.$target?.fullyQualifiedName) {
                appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.target] =
                    selectionField.$target.fullyQualifiedName.split('/')[0];
            }
            appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.annotationType] = selectionField?.type;
            appSchema.definitions[fieldDefinition][ux_specification_types_1.SchemaTag.annotationPath] = `${selectionFieldsDefinition[ux_specification_types_1.SchemaTag.annotationPath]}/${i}`;
            i++;
        });
    }
    return selectionFieldsDefinition;
}
exports.addSelectionFields = addSelectionFields;
function defineActions(appSchema, schemaIdForActions, annotations, targetAnnotation, entityType) {
    appSchema.definitions[schemaIdForActions] = JSON.parse(JSON.stringify(appSchema.definitions['Actions']));
    const actions = appSchema.definitions[schemaIdForActions];
    actions.properties = {};
    actions.additionalProperties = false;
    const chartAnnotation = annotations[targetAnnotation?.split(`${ux_specification_types_1.UIVOCABULARY}.`)[1]];
    if (chartAnnotation && chartAnnotation.Actions) {
        let i = 0;
        chartAnnotation.Actions.forEach((actionRecord) => {
            const actionDefinition = (0, common_1.prepareRef)(`${ux_specification_types_1.DefinitionName.ChartToolBarAction}<${actionRecord.Action}>`);
            const description = (0, common_1.getDataFieldDescription)(actionRecord, entityType);
            const prefix = actionRecord.$Type.split(`${ux_specification_types_1.UIVOCABULARY}.`)[1];
            const action = (actions.properties[`${prefix}::${actionRecord.Action}`] = {
                $ref: common_1.DEFINITION_LINK_PREFIX + actionDefinition,
                description
            });
            //Add tags
            action[ux_specification_types_1.SchemaTag.propertyIndex] = i;
            action[ux_specification_types_1.SchemaTag.annotationType] = actionRecord.$Type;
            action[ux_specification_types_1.SchemaTag.annotationPath] = `/${actionRecord.fullyQualifiedName}`;
            //as ChartToolBarAction is an empty object, copy ViewToolBarAction and remove properties
            appSchema.definitions[actionDefinition] = JSON.parse(JSON.stringify(appSchema.definitions[ux_specification_types_1.DefinitionName.ViewToolBarAction]));
            appSchema.definitions[actionDefinition].properties = {};
            appSchema.definitions[actionDefinition][ux_specification_types_1.SchemaTag.annotationPath] = actionRecord.fullyQualifiedName;
            i++;
        });
    }
}
/**
 * Finds the right visualization for a given view
 * @param allVisualizations - list of visualizations for the given (S)PV
 * @param namespace - namespace for the UI annotations
 * @param viewKey - view key: primary, secondary, or anything else; may also be undefined. The first visualization is taken in this case.
 * @param visualizationType - allows to find the right visualization if there are many.
 * @returns the value of the first fitting visualization
 */
function findTheRightVisualization(allVisualizations, namespace, viewKey, visualizationType) {
    let visualization, visualizationObject, targetAnnotation;
    if (allVisualizations) {
        if (viewKey === 'primary') {
            visualizationObject = allVisualizations.find((vis) => {
                return vis['value'].indexOf('Chart') > -1;
            });
        }
        else if (viewKey === 'secondary') {
            visualizationObject = allVisualizations.find((vis) => {
                return vis['value'].indexOf(ux_specification_types_1.FacetBase.LineItem) > -1;
            });
        }
        else {
            if (visualizationType) {
                visualizationObject = allVisualizations.find((v) => v['value'].indexOf(visualizationType) > -1);
            }
            else {
                visualizationObject = allVisualizations[0];
            }
        }
        visualization = (0, common_1.replaceNamespaces)(visualizationObject?.['value']);
        if (visualizationObject?.['$target']?.fullyQualifiedName) {
            targetAnnotation = `/${namespace}/${visualizationObject['$target'].fullyQualifiedName.split(namespace)[1]}`;
        }
        else if (visualization) {
            targetAnnotation = `/${namespace}/` + visualization.replace(`UI`, ux_specification_types_1.UIVOCABULARY);
        }
    }
    return { visualization, targetAnnotation };
}
/**
 * An annotationPath must be analyzed, to find the right target annotation and visualization
 *
 */
function analyzeChartAnnotation(namespace, annotationPath, annotationAVT, viewKey) {
    const visualization = '@UI.Chart';
    const targetAnnotationFullName = `/${namespace}/@${annotationPath}`;
    let chartTitle;
    if (annotationAVT['Title']) {
        chartTitle = annotationAVT['Title'];
    }
    else {
        chartTitle = `Chart View (${viewKey})`;
    }
    return { visualization, targetAnnotation: targetAnnotationFullName, chartTitle };
}
/**
 * An annotationPath must be analyzed, to find the right target annotation and visualization
 * @param annotationPath - given annotationPath
 * @param uIAnnotations - annotations of UI namespace of the given entityType
 * @param generateParameters - parameters required to generate app schema
 * @param viewKey - allows to distinguish the different view types (LR or ALP)
 * @param visualizationType - allows to find the right visualization if there are many.
 * @returns { visualization: string describing the visualization of the annotation,
 *            targetAnnotation: the target annotation behind the visualization
 *            namespace: namespace of the annotation,
 *            title: title to be shown, derived from the annotation }
 */
function analyzeViewAnnotation(annotationPath, uIAnnotations, generateParameters, viewKey, visualizationType) {
    let namespace = undefined, title;
    const UILINEITEM = '@UI.LineItem';
    const annotationInManifest = annotationPath?.split(`${ux_specification_types_1.UIVOCABULARY}.`)[1];
    const annotationAVT = annotationInManifest && uIAnnotations[annotationInManifest];
    if (!annotationAVT) {
        return { visualization: undefined, targetAnnotation: undefined, namespace, title: `View (${viewKey})` };
    }
    title = annotationAVT.Text;
    namespace = annotationAVT.fullyQualifiedName.split(ux_specification_types_1.UIVOCABULARYALPHADOT)[0];
    if (annotationInManifest.startsWith('PresentationVariant')) {
        const { visualization, targetAnnotation } = findTheRightVisualization(annotationAVT.Visualizations, namespace, viewKey, visualizationType);
        title = title || `View (${viewKey})`;
        return { visualization, targetAnnotation, namespace, title };
    }
    else if (annotationInManifest.startsWith('SelectionPresentationVariant')) {
        let { visualization, targetAnnotation } = findTheRightVisualization(annotationAVT.PresentationVariant?.Visualizations, namespace, viewKey, visualizationType);
        if (!visualization) {
            visualization = UILINEITEM; // default visualization
            targetAnnotation = `/${namespace}/` + visualization.replace(`UI`, ux_specification_types_1.UIVOCABULARY); // default targetAnnotation
        }
        title = title || `View (${viewKey})`;
        return { visualization, targetAnnotation, namespace, title };
    }
    else if (annotationInManifest.startsWith('SelectionVariant')) {
        const visualization = UILINEITEM;
        const targetAnnotation = `/${namespace}/@${"com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */}`;
        title = title || `Table View (${viewKey})`;
        return { visualization, targetAnnotation, namespace, title };
    }
    else if (annotationInManifest.startsWith('LineItem')) {
        const visualization = UILINEITEM;
        const targetAnnotation = `/${namespace}/@${annotationPath}`;
        title = title || `Table View (${viewKey})`;
        return { visualization, targetAnnotation, namespace, title };
    }
    else if (annotationInManifest.startsWith('Chart')) {
        const { visualization, targetAnnotation, chartTitle } = analyzeChartAnnotation(namespace, annotationPath, annotationAVT, viewKey);
        return { visualization, targetAnnotation, namespace, title: chartTitle };
    }
    return { visualization: undefined, targetAnnotation: undefined, namespace, title: `View (${viewKey})` };
}
/**
 * Adds the ALP chart view to the app-specific schema
 * @param {Definition} appSchema - app-specific JSON schema
 * @param targetAnnotation - target annotation of the chart view, as determined by analyzeViewAnnotation
 * @param annotations - UI annotations, as determined by AVT
 */
function addALPChartView(appSchema, chartAnnotationPath, targetAnnotation, annotations) {
    const chartView = appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChartView];
    appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChart] = JSON.parse(JSON.stringify(chartView));
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChart][ux_specification_types_1.SchemaTag.isViewNode];
    if (targetAnnotation) {
        appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChart][ux_specification_types_1.SchemaTag.annotationPath] = targetAnnotation;
    }
    appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChart].properties.annotationPath[ux_specification_types_1.SchemaTag.hidden] = true;
    chartView.properties.annotationPath[ux_specification_types_1.SchemaTag.hidden] = true;
    chartView.additionalProperties = false;
    chartView.description = `Chart (key: primary)`;
    chartView.title = `Chart`;
    chartView.$ref = `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ALPChart}`;
    if (chartAnnotationPath) {
        const viewAnnotation = chartAnnotationPath.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
        const pathParts = annotations[viewAnnotation].fullyQualifiedName.split('@');
        chartView[ux_specification_types_1.SchemaTag.annotationPath] = `/${pathParts[0]}/@${pathParts[1]}`;
    }
    chartView[ux_specification_types_1.SchemaTag.artifactType] = ux_specification_types_1.ArtifactType.Manifest;
    chartView[ux_specification_types_1.SchemaTag.key] = 'primary';
    chartView[ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.key, value: 'primary' }];
}
/**
 * Adds the ALP views to the app-specific schema
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {Array<Object>} viewsPaths - views' paths' section in the manifest
 * @param {EntityType} entityType - actual entity type of the page's entitySet
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param templateAnnotation - defaultTemplateAnnotationPath as registered in manifest
 */
function addALPViews(appSchema, viewsPaths, entityType, generateParameters, templateAnnotation, tableDefinitionName) {
    const annotations = entityType?.annotations.UI;
    //1. Chart View
    const chartAnnotationPath = viewsPaths?.[0]?.['primary']?.[0]?.[ux_specification_types_1.SchemaTag.annotationPath];
    const { targetAnnotation } = analyzeViewAnnotation(chartAnnotationPath, annotations, generateParameters, 'primary');
    addALPChartView(appSchema, chartAnnotationPath, targetAnnotation, annotations);
    // Copy toolbar
    const schemaIdForActions = `Actions<ALPChart>`;
    appSchema.definitions[ux_specification_types_1.DefinitionName.ViewChartToolBar].properties.actions['$ref'] =
        common_1.DEFINITION_LINK_PREFIX + schemaIdForActions;
    defineActions(appSchema, schemaIdForActions, annotations, targetAnnotation, entityType);
    //2. Table View
    const { visualization: tableVisualization, targetAnnotation: target } = analyzeViewAnnotation(viewsPaths?.[0]?.['secondary']?.[0]?.[ux_specification_types_1.SchemaTag.annotationPath], annotations, generateParameters, 'secondary');
    const tableDefinition = appSchema.definitions[tableDefinitionName];
    if (tableVisualization || templateAnnotation) {
        tableDefinition.properties.toolBar['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ToolBarLR}`;
        // Switch from generic column to specific definition
        tableDefinition.properties['columns'] = {
            $ref: common_1.DEFINITION_LINK_PREFIX + ux_specification_types_1.DefinitionName.LineItems
        };
        tableDefinition.properties.annotationPath[ux_specification_types_1.SchemaTag.hidden] = true;
    }
    else {
        tableDefinition.properties = {};
    }
    const tableView = appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTableView];
    appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTable] = JSON.parse(JSON.stringify(tableView));
    delete appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTable][ux_specification_types_1.SchemaTag.isViewNode];
    tableView.additionalProperties = false;
    tableView.description = `Table (key: secondary)`;
    tableView.title = `Table`;
    if (tableVisualization) {
        delete tableView.properties;
        tableView.$ref = `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ALPTable}`;
    }
    else if (!templateAnnotation) {
        tableView.properties = {};
    }
    tableView[ux_specification_types_1.SchemaTag.artifactType] = ux_specification_types_1.ArtifactType.Manifest;
    let annotationTerm, viewAnnotation;
    if (tableVisualization && tableVisualization.indexOf(ux_specification_types_1.FacetBase.LineItem) > -1) {
        annotationTerm = tableVisualization.split('.')[1];
        viewAnnotation = viewsPaths[0]['secondary'][0].annotationPath.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
    }
    else if (templateAnnotation) {
        annotationTerm = viewAnnotation = templateAnnotation.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
    }
    if (annotationTerm) {
        const dataForLineItem = {
            appSchema,
            lineItemAnnotation: entityType?.annotations.UI[annotationTerm],
            entityType,
            oDataServiceAVT: generateParameters.serviceAVT,
            lineItemId: ux_specification_types_1.DefinitionName.LineItems
        };
        (0, utils_1.addLineItemsTypeToSchema)(dataForLineItem, ux_specification_types_1.DefinitionName.ViewTableColumn);
        if (target) {
            appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTable][ux_specification_types_1.SchemaTag.annotationPath] = target;
        }
        const pathParts = annotations[viewAnnotation].fullyQualifiedName.split('@');
        tableView[ux_specification_types_1.SchemaTag.annotationPath] = `/${pathParts[0]}/@${pathParts[1]}`;
        tableView[ux_specification_types_1.SchemaTag.key] = 'secondary';
        tableView[ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.key, value: 'secondary' }];
    }
}
/**
 * Modifies the app schema, adds the right line chart settings
 * @param inputParameters - list of input parameters as collected by the calling instance
 * @param annotations - UI annotations of the given entityType
 * @returns the ID for the chart view in schema
 */
function addViewChartDefinitions(inputParameters, annotations) {
    const idForChart = `${ux_specification_types_1.DefinitionName.LRChartView}<${inputParameters.viewKey}>`;
    inputParameters.appSchema.definitions[idForChart] = JSON.parse(JSON.stringify(inputParameters.appSchema.definitions[ux_specification_types_1.DefinitionName.LRChartView]));
    delete inputParameters.appSchema.definitions[idForChart][ux_specification_types_1.SchemaTag.isViewNode];
    inputParameters.appSchema.definitions[idForChart][ux_specification_types_1.SchemaTag.annotationPath] = inputParameters.targetAnnotation;
    if (inputParameters.navPropName) {
        inputParameters.appSchema.definitions[idForChart]['navigationProperty'] = inputParameters.navPropName;
    }
    //Copy toolbar
    const idForToolbar = `${ux_specification_types_1.DefinitionName.ViewChartToolBar}<${inputParameters.viewKey}>`;
    inputParameters.appSchema.definitions[idForToolbar] = JSON.parse(JSON.stringify(inputParameters.appSchema.definitions[ux_specification_types_1.DefinitionName.ViewChartToolBar]));
    inputParameters.appSchema.definitions[idForChart]['properties'].toolBar.$ref = `${common_1.DEFINITION_LINK_PREFIX}${idForToolbar}`;
    //Copy actions
    const schemaIdForActions = `${ux_specification_types_1.DefinitionName.Actions}<${inputParameters.viewKey}>`;
    defineActions(inputParameters.appSchema, schemaIdForActions, annotations, inputParameters.targetAnnotation, inputParameters.targetEntityType);
    inputParameters.appSchema.definitions[idForToolbar]['properties'][ux_specification_types_1.PropertyName.actions]['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${schemaIdForActions}`;
    return idForChart;
}
/**
 * Adds the definition of a chart view to the app schema
 * @param inputParameters - list of input parameters as collected by the calling instance
 * @param UIAnnotations - AVT UI annotations of the given entity type
 * @param appSchema - app schema
 * @param viewsDefinition - the views definition in app schema (MultiTableModeV4)
 * @param viewKey - view key
 * @param title - view title
 */
function addViewChart(inputParameters, UIAnnotations, appSchema, viewsDefinition, viewKey, title) {
    const idForChart = addViewChartDefinitions(inputParameters, UIAnnotations);
    appSchema.definitions[idForChart].properties.annotationPath[ux_specification_types_1.SchemaTag.hidden] = true;
    appSchema.definitions[idForChart].properties.index[ux_specification_types_1.SchemaTag.hidden] = true;
    appSchema.definitions[idForChart].properties.entitySet[ux_specification_types_1.SchemaTag.hidden] = true;
    const titleOnHover = `Chart View (key: ${viewKey})`;
    viewsDefinition.properties[viewKey] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${idForChart}`,
        description: title ? title : titleOnHover,
        title: titleOnHover
    };
}
/**
 * Empties properties for given definition.
 * @param {DefinitionOrBoolean} definition - the given definition
 */
function createEmptyProperties(definition) {
    if (typeof definition === 'object') {
        return {
            ...definition,
            properties: {}
        };
    }
    return {
        properties: {}
    };
}
/**
 * Modifies the app schema, adds the right line item settings as derived from the visualization
 * @param inputParameters - list of input parameters as collected by the calling instance
 * @param viewsDefinition - the views definition in app schema (MultiTableModeV4)
 * @param visualization - visualization from the given (S)PV
 * @param templateAnnotation - defaultTemplateAnnotationPath as registered in manifest
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 */
function addViewLineItems(inputParameters, viewsDefinition, visualization, templateAnnotation, generateParameters) {
    const tableId = `${ux_specification_types_1.DefinitionName.LRTableView}<${inputParameters.viewKey}>`;
    const viewId = `${ux_specification_types_1.DefinitionName.LineItemsOfView}::${inputParameters.viewKey}`;
    const lrTableView = (0, common_1.parseSchemaDefinition)(ux_specification_types_1.DefinitionName.LRTableView, inputParameters.viewKey, inputParameters.appSchema);
    delete lrTableView[ux_specification_types_1.SchemaTag.isViewNode];
    lrTableView[ux_specification_types_1.SchemaTag.annotationPath] = inputParameters.targetAnnotation;
    if (inputParameters.navPropName) {
        lrTableView['navigationProperty'] = inputParameters.navPropName;
    }
    if (inputParameters.entitySet) {
        lrTableView['entitySet'] = inputParameters.entitySet;
    }
    //Copy toolbar
    (0, common_1.addDefinitionRef)(lrTableView.properties.toolBar, ux_specification_types_1.DefinitionName.ToolBar, viewId);
    const title = `Table View (key: ${inputParameters.viewKey})`;
    viewsDefinition.properties[inputParameters.viewKey] = {
        $ref: `${common_1.DEFINITION_LINK_PREFIX}${tableId}`,
        description: inputParameters.title || title,
        title
    };
    (0, common_1.addDefinitionRef)(lrTableView.properties.columns, viewId);
    lrTableView.properties.annotationPath[ux_specification_types_1.SchemaTag.hidden] = true;
    lrTableView.properties.index[ux_specification_types_1.SchemaTag.hidden] = true;
    lrTableView.properties.entitySet[ux_specification_types_1.SchemaTag.hidden] = true;
    const annotationTerm = visualization?.split('.')[1] || templateAnnotation.split(ux_specification_types_1.UIVOCABULARYDOT)[1];
    const dataForLineItem = {
        appSchema: inputParameters.appSchema,
        lineItemAnnotation: inputParameters.targetEntityType?.annotations.UI[annotationTerm],
        entityType: inputParameters.targetEntityType,
        oDataServiceAVT: generateParameters.serviceAVT,
        lineItemId: viewId,
        entitySet: lrTableView['entitySet']
    };
    let columnDefinitionName = ux_specification_types_1.DefinitionName.ViewTableColumn;
    // handle basic columns and basic actions for view with different entity set (remove properties)
    if (lrTableView['entitySet'] !== undefined) {
        const { definitions } = inputParameters.appSchema;
        // will be used as new reference
        columnDefinitionName = ux_specification_types_1.DefinitionName.ViewTableColumnBasic;
        const originalReference = definitions[ux_specification_types_1.DefinitionName.ViewTableColumn];
        definitions[columnDefinitionName] = createEmptyProperties(originalReference);
        const actionRef = ux_specification_types_1.DefinitionName.ViewTableColumnBasicAction;
        const originalActionRef = `${ux_specification_types_1.DefinitionName.ViewTableColumnAction}`;
        definitions[actionRef] = createEmptyProperties(definitions[originalActionRef]);
    }
    (0, utils_1.addLineItemsTypeToSchema)(dataForLineItem, columnDefinitionName);
}
/**
 * Adds the schema tags to a given view
 * @param viewsDefinition - the views definition in app schema (MultiTableModeV4)
 * @param viewKey - key property of the view
 * @param namespace - target namespace for annotations
 * @param view - the given view
 */
function addTagsToView(viewsDefinition, viewKey, namespace, view) {
    viewsDefinition.properties[viewKey][ux_specification_types_1.SchemaTag.isViewNode] = true;
    viewsDefinition.properties[viewKey][ux_specification_types_1.SchemaTag.annotationPath] = namespace
        ? `/${namespace}/@${view[ux_specification_types_1.SchemaTag.annotationPath]}`
        : undefined;
    viewsDefinition.properties[viewKey][ux_specification_types_1.SchemaTag.artifactType] = ux_specification_types_1.ArtifactType.Manifest;
    viewsDefinition.properties[viewKey][ux_specification_types_1.SchemaTag.key] = viewKey;
    viewsDefinition.properties[viewKey][ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.key, value: viewKey }];
}
/**
 * Adjusts the entity type if a different entity set is maintained for a view
 * @param {EntitySet} entitySet - actual entity set (AVT information)
 * @param view - the current view in manifest
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {EntityType} entityType - actual entity type of the page's entitySet
 * @returns the target entity type
 */
function getTargetEntityType(entitySet, view, generateParameters, entityType) {
    let targetEntityType = entityType;
    let viewEntitySet = entitySet;
    if (view['entitySet'] && view['entitySet'] !== entitySet.name) {
        viewEntitySet = generateParameters.serviceAVT?.entitySets.find((es) => {
            return es.name === view['entitySet'];
        });
        targetEntityType = viewEntitySet.entityType;
    }
    return targetEntityType;
}
/**
 * Handles manifest properties for given view definition excluding passed ones.
 * @param {Definition} definition - the given definition
 * @param {string[]} validProperties - properties to skip from deletion
 */
function handleViewProperties(definition, validProperties) {
    const { properties } = definition;
    if (properties) {
        for (const i in properties) {
            if (properties[i]['artifactType'] === ux_specification_types_1.ArtifactType.Manifest && validProperties.indexOf(i) === -1) {
                delete properties[i];
            }
        }
    }
}
/**
 * Adds definition parts to a LR View (LineItem/Chart)
 * @param {string} templateAnnotation - defaultTemplateAnnotationPath as registered in manifest
 * @param {string} visualization - visualization of the annotation
 * @param viewsDefinition - the views definition in app schema (MultiTableModeV4)
 * @param {object} commonInputParameters - list of input parameters as collected by the calling instance
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {SapUiAppPageV4} v4Page - the given page in manifest
 * @param {object} uiAnnotations - UI annotations of the given entityType
 * @param {object} view - the given view
 */
function addLRViewParts(visualization, viewsDefinition, commonInputParameters, generateParameters, v4Page, uiAnnotations, view) {
    if (visualization?.indexOf(ux_specification_types_1.Visualization.LineItem) > -1) {
        //Add Line item view
        addViewLineItems(commonInputParameters, viewsDefinition, visualization, commonInputParameters.targetAnnotation, generateParameters);
        if (view['entitySet'] !== undefined) {
            // handle root properties of current view if entity set is different
            handleViewProperties(commonInputParameters.appSchema.definitions[`${ux_specification_types_1.DefinitionName.LRTableView}<${view['key']}>`], ['visible']);
        }
    }
    else if (visualization?.indexOf('Chart') > -1) {
        //Add Chart view
        addViewChart(commonInputParameters, uiAnnotations, commonInputParameters.appSchema, viewsDefinition, commonInputParameters.viewKey, commonInputParameters.title);
    }
    else if (view['template']) {
        const titleOnHover = view['label'] || `Custom View (key: ${commonInputParameters.viewKey})`;
        viewsDefinition.properties[commonInputParameters.viewKey] = {
            description: commonInputParameters.title || titleOnHover,
            title: titleOnHover,
            // Default view - use table view reference as default
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.TableViewExtension}`
        };
    }
    else {
        const titleOnHover = `View (key: ${commonInputParameters.viewKey})`;
        viewsDefinition.properties[commonInputParameters.viewKey] = {
            description: commonInputParameters.title || titleOnHover,
            title: titleOnHover,
            // Default view - use table view reference as default
            $ref: `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.LRTableView}`
        };
    }
}
/**
 * Add list report views to the app-specific schema
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {Array<Object>} viewsPaths - views' paths' section in the manifest
 * @param {EntityType} entityType - actual entity type of the page's entitySet
 * @param {EntitySet} entitySet - actual entity set (AVT information)
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {string} templateAnnotation - defaultTemplateAnnotationPath as registered in manifest
 * @param {SapUiAppPageV4} v4Page - the given page in manifest
 */
function addLRViews(appSchema, viewsPaths, entityType, entitySet, generateParameters, v4Page, tableDefinitionName) {
    const tableDefinition = appSchema.definitions[tableDefinitionName];
    tableDefinition.properties = {
        annotationPath: tableDefinition.properties.annotationPath,
        initialLoad: tableDefinition.properties.initialLoad,
        views: tableDefinition.properties.views
    };
    const viewsDefinition = appSchema.definitions.MultiTableModeV4;
    for (const view of viewsPaths) {
        if (!view[ux_specification_types_1.SchemaTag.key]) {
            continue;
        }
        let navPropName = undefined;
        const targetEntityType = getTargetEntityType(entitySet, view, generateParameters, entityType);
        const uiAnnotations = targetEntityType?.annotations.UI;
        const { visualization, targetAnnotation, namespace, title } = analyzeViewAnnotation(view?.[ux_specification_types_1.SchemaTag.annotationPath], uiAnnotations, generateParameters, view[ux_specification_types_1.SchemaTag.key]);
        if (view['entitySet']) {
            navPropName = entityType.navigationProperties.find((np) => {
                return np.targetTypeName === namespace;
            })?.name;
        }
        const viewKey = (0, common_1.prepareRef)(view[ux_specification_types_1.SchemaTag.key]);
        const commonInputParameters = {
            viewKey,
            appSchema,
            targetAnnotation,
            navPropName,
            targetEntityType,
            title,
            entitySet: view['entitySet']
        };
        addLRViewParts(visualization, viewsDefinition, commonInputParameters, generateParameters, v4Page, uiAnnotations, view);
        addTagsToView(viewsDefinition, viewKey, namespace, view);
    }
}
/**
 * Adapts the table definition in schema.
 * Evaluates the path depending on if defaultTemplateAnnotationPath or Selection-/PresentationVariant is present.
 * @param {SapUiAppPageV4} v4Page - the given page in manifest
 * @param {EntityType} entityType - the current entity type, as defined in AVT
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param appSchema - the app-specific JSON schema
 * @param alias - alias definition for the UI vocabulary
 */
function adaptTableDefinition(appSchema, entityType, generateParameters, templateAnnotation, v4Page, alias, tableDefinitionName) {
    //here: tableDefinitionName = DefinitionName.Table
    const tableDefinition = appSchema.definitions[tableDefinitionName];
    const { visualization, targetAnnotation, namespace } = analyzeViewAnnotation(templateAnnotation, entityType.annotations.UI, generateParameters, undefined, ux_specification_types_1.Visualization.LineItem);
    if (visualization) {
        const annotationTerm = visualization.split('.')[1];
        const annotationTermInSchema = `${ux_specification_types_1.DefinitionName.LineItems}OfSPV::${(0, common_1.prepareRef)(annotationTerm)}`;
        const spvTable = (appSchema.definitions[`${tableDefinitionName}SPV`] = JSON.parse(JSON.stringify(appSchema.definitions[tableDefinitionName])));
        delete spvTable[ux_specification_types_1.SchemaTag.isViewNode];
        (0, common_1.addDefinitionRef)(spvTable.properties.toolBar, ux_specification_types_1.DefinitionName.ToolBar, annotationTermInSchema);
        // Switch from generic column to specific definition
        spvTable[ux_specification_types_1.SchemaTag.annotationPath] = targetAnnotation;
        spvTable.properties.columns = {};
        (0, common_1.addDefinitionRef)(spvTable.properties.columns, annotationTermInSchema);
        delete tableDefinition.properties;
        (0, common_1.addDefinitionRef)(tableDefinition, `${tableDefinitionName}SPV`);
        tableDefinition[ux_specification_types_1.SchemaTag.annotationPath] = `/${namespace}/@${templateAnnotation}`;
        const lineItemAnnotation = entityType?.annotations.UI[annotationTerm];
        if (!lineItemAnnotation) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOTARGET', { target: annotationTerm }),
                location: {
                    path: ux_specification_types_1.METADATAPATH
                }
            });
        }
        const dataForLineItem = {
            appSchema,
            lineItemAnnotation,
            entityType,
            oDataServiceAVT: generateParameters.serviceAVT,
            lineItemId: annotationTermInSchema
        };
        (0, utils_1.addLineItemsTypeToSchema)(dataForLineItem);
    }
    else {
        tableDefinition.properties.toolBar['$ref'] = `${common_1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.ToolBarLR}`;
        // Switch from generic column to specific definition
        (0, common_1.addDefinitionRef)(tableDefinition.properties.columns, ux_specification_types_1.DefinitionName.LineItems);
        const lineItemAnnotation = entityType?.annotations?.[alias]?.LineItem;
        if (!lineItemAnnotation) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOLINEITEMS'),
                location: {
                    path: ux_specification_types_1.METADATAPATH
                }
            });
        }
        const dataForLineItem = {
            appSchema,
            lineItemAnnotation,
            entityType,
            oDataServiceAVT: generateParameters.serviceAVT,
            lineItemId: ux_specification_types_1.DefinitionName.LineItems
        };
        (0, utils_1.addLineItemsTypeToSchema)(dataForLineItem);
        const term = lineItemAnnotation ? lineItemAnnotation.term : "com.sap.vocabularies.UI.v1.LineItem" /* UIAnnotationTerms.LineItem */;
        tableDefinition[ux_specification_types_1.SchemaTag.annotationPath] = (0, common_1.createAnnotationPath)(entityType?.fullyQualifiedName, term, lineItemAnnotation?.qualifier);
    }
}
/**
 * Checks for the default annotation path to use for LR table
 * @param {SapUiAppPageV4} v4Page - actual page in the manifest
 * @param {EntityType} entityType - actual entity type (AVT information)
 * @returns {string} annotation term
 */
function getDefaultAnnotationPath(v4Page, entityType, templateType) {
    if (v4Page.options.settings?.views?.paths && templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
        return;
    }
    if (v4Page.options.settings?.defaultTemplateAnnotationPath) {
        return v4Page.options.settings.defaultTemplateAnnotationPath;
    }
    if (templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
        return (entityType.annotations.UI?.SelectionPresentationVariant?.term ||
            entityType.annotations.UI?.PresentationVariant?.term);
    }
}
/**
 * Add views to schema (LR or ALP)
 * @param {Definition} appSchema - app-specific JSON schema
 * @param {SapUiAppPageV4} v4Page - actual page in the manifest
 * @param {EntityType} entityType - actual entity type (AVT information)
 * @param {EntitySet} entitySet - actual entity set (AVT information)
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 */
function addTableAndViews(appSchema, v4Page, entityType, entitySet, generateParameters, alias) {
    const viewsPaths = v4Page.options?.settings?.views?.paths;
    const defaultAnnotation = getDefaultAnnotationPath(v4Page, entityType, generateParameters.templateType);
    const tableDefinitionName = (0, utils_1.alignSchemaWithTemplateType)(appSchema, generateParameters);
    if (generateParameters.templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
        if (viewsPaths) {
            addLRViews(appSchema, viewsPaths, entityType, entitySet, generateParameters, v4Page, tableDefinitionName);
        }
        else {
            if (!v4Page.options?.settings?.views) {
                appSchema.definitions.MultiTableModeV4.properties = {};
            }
            adaptTableDefinition(appSchema, entityType, generateParameters, defaultAnnotation, v4Page, alias, tableDefinitionName);
        }
        appSchema.properties[ux_specification_types_1.PropertyName.chart][ux_specification_types_1.SchemaTag.hidden] = true;
    }
    else if (generateParameters.templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
        addALPViews(appSchema, viewsPaths, entityType, generateParameters, defaultAnnotation, tableDefinitionName);
    }
}
/**
 * Generates an app specific schema for the FE V4 ListReport from the generic schema.
 * Generic types are replaced by information from the app specific annotations.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param genericSchema  - generic JSON schema of an object page
 * @param {EntitySet} entitySet - entity set (AVT object) that is relevant for the given page
 * @param {string} templateName - allows to distinguish list report from ALP
 *
 * @returns {object} application-specific schema of the list report
 */
function generateListReportSchemaV4(generateParameters, genericSchema, entitySet, templateName) {
    const appSchema = JSON.parse(JSON.stringify(genericSchema));
    const entityType = entitySet?.entityType;
    const alias = generateParameters.serviceAVT && (0, common_1.findAlias)(ux_specification_types_1.UIVOCABULARY, generateParameters.serviceAVT);
    //Add selection fields
    const selectionFieldAnnotation = alias && entityType?.annotations?.[alias]?.SelectionFields;
    addSelectionFields(entityType, appSchema, selectionFieldAnnotation);
    appSchema.properties[ux_specification_types_1.PropertyName.defaultTemplateAnnotationPath][ux_specification_types_1.SchemaTag.hidden] = true;
    //enum for annotation path as part of QuickVariantSelection
    (0, common_1.addEnumForSingleTabVariant)(entityType, appSchema, ux_specification_types_1.DefinitionName.AnnotationPathAsObject);
    if (generateParameters.manifest) {
        //Find page in targets
        const pages = generateParameters.manifest[ux_specification_types_1.ManifestSection.ui5].routing
            .targets;
        if (!pages) {
            (0, extensionLogger_1.log)(generateParameters.logger, {
                severity: "error" /* LogSeverity.Error */,
                message: i18next_1.default.t('NOPAGES', { appId: generateParameters.manifest['sap.app']['id'] }),
                location: {
                    path: ux_specification_types_1.MANIFESTPATH,
                    range: [ux_specification_types_1.ManifestSection.generic]
                }
            });
            return appSchema;
        }
        const v4Page = (0, utils_1.findPageV4)(pages, templateName, entitySet, generateParameters.logger);
        if (!v4Page) {
            return appSchema;
        }
        addTableAndViews(appSchema, v4Page, entityType, entitySet, generateParameters, alias);
    }
    delete appSchema.definitions.GenericColumns;
    delete appSchema.definitions.Action;
    (0, common_1.updatePropertyIndices)(appSchema, ROOT_PROPERTIES_ORDER);
    return appSchema;
}
exports.generateListReportSchemaV4 = generateListReportSchemaV4;
//# sourceMappingURL=listReport.js.map